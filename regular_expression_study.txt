^匹配字符串的开始
$匹配字符串的结束
.匹配除换行符以外的任意字符
\d匹配数字
\s匹配任意的空白符
\w匹配字母或数字
\b匹配单词的开始或结束

\W	匹配任意不是字母和数字的字符
\S	匹配任意不是空白符的字符
\D	匹配任意非数字的字符
\B	匹配不是单词开头或结束的位置
[^x]	匹配除了x以外的任意字符
[^aeiou]	匹配除了aeiou这几个字母以外的任意字符

*重复零次或更多次
+重复一次或更多次
?重复零次或一次
\{n\}重复n次
\{n,\}重复n次或更多次
\{n,m\}重复n到m次

*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复


(exp)	匹配exp,并捕获文本到自动命名的组里
(?<name>exp)	匹配exp,并捕获文本到名称为name的组里
(?:exp)	匹配exp,不捕获匹配的文本
(?=exp)	匹配exp前面的位置
(?<=exp)	匹配exp后面的位置
(?!exp)	匹配后面跟的不是exp的位置
(?<!exp)	匹配前面不是exp的位置
(?#comment)	这种类型的组不对正则表达式的处理产生任何影响，只是为了提供让人阅读注释


[0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。
abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。
假如你要找的是hi后面不远处跟着一个Lucy，你应该用\bhi\b.*\bLucy\b
0\d\d-\d\d\d\d\d\d\d\d代表着这样的字符串：以0开头，然后是两个数字，然后是一个连字号“-”，最后是8个数字(也就是中国的电话号码，当然，这个例子只能匹配区号为3位的情形
\ba\w*\b匹配以字母a开头的单词-先是某个单词开始处(\b)，然后是字母a,然后是任意数量的字母或数字(\w*)，最后是单词结束处(\b)。
\d+匹配1个或更多连续的数字。这里的+是和*类似的特殊代码，不同的是*代表重复任意次(可能是0次)，而+则代表重复1次或更多次。
\b\w\{6\}\b 匹配刚好6个字母/数字的单词。
比如一个网站如果要求你填写的QQ号必须为5位到12位数字时，可以使用：^\d\{5,12\}$。这里的{5,12}和前面介绍过的{2}是类似的，只不过{2}代表只能不多不少重复2次，{5,12}则是必须重复最少5次，最多12次，否则都不匹配。
如果你想查找特殊代码本身的话，比如你查找.,或者*,就出现了问题：你没法指定它们，因为它们会被解释成其它的意思。这时你就必须使用\来取消这些字符的特殊意义。因此，你应该使用\.和\*。当然，要查找\本身，你也得用\\.
例如：deerchao\.net匹配deerchao.net，c:\\windows匹配c:\windows,2\^8匹配2^8(通常这是2的8次方的书写方式)。

Windows\d+匹配Windows后面跟1个或更多数字
13\d\{9\}匹配以13后面跟9个数字(中国的手机号)
^\w+匹配一行的第一个单词(或整个字符串的第一个单词，具体代表哪个意思得看选项设置)
[aeiou]就匹配任何一个元音字母
[.?!]匹配标点符号(.或?或!)
[0-9]代表的含意与\d就是完全一致的
一位数字，同理[a-z0-9A-Z]也完全等同于\w
下面是一个更复杂的表达式：\(?0\d{2}[) -]?\d{8} 
这个表达式可以匹配几种格式的电话号码，像(010)88886666，或022-22334455，或02912345678等。我们对它进行一些分析吧：首先是一个转义字符\(,它能出现0次或1次(?),然后是一个0，后面跟着2个数字({2})，然后是)或-或空格中的一个，它出现1次或不出现(?)，最后是8个数字(\d{8})。不幸的是，它也能匹配010)12345678或(022-87654321这样的“不正确”的格式

0\d{2}-\d{8}|0\d{3}-\d{7}这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8位本地号(如010-12345678)，一种是4位区号，7位本地号(0376-2233445)
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8}这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。你可以试试用替换|把这个表达式扩展成也支持4位区号的。
\d{5}-\d{4}|\d{5}这个表达式用于匹配美国的邮政编码。美国邮编的规则是5位数字，或者用连字号间隔的9位数字。之所以要给出这个例子是因为它能说明一个问题：使用替换时，顺序是很重要的。如果你把它改成\d{5}|\d{5}-\d{4}的话，那么就只会匹配5位的邮编(以及9位邮编的前5位)。原因是匹配替换时，将会从左到右地测试每个条件，如果满足了某个条件的话，就不会去管其它的替换条件了。
Windows98|Windows2000|WindosXP这个例子是为了告诉你替换不仅仅能用于两种规则，也能用于更多种规则。
(\d\{1,3\}\.)\{3\}\d\{1,3\}是一个简单的IP地址匹配表达式  要理解这个表达式，请按下列顺序分析它：\d{1,3}代表1到3位的数字，(\d{1,3}\.}{3}代表三位数字加上一个英文句号(这个整体也就是这个分组)重复3次，最后再加上一个一到三位的数字(\d{1,3})。
不幸的是，它也将匹配256.300.888.999这种不可能存在的IP地址(IP地址中每个数字都不能大于255)。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的IP地址：((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)
\b(\w+)\b\s+\1\b可以用来匹配重复的单词，像go go, kitty kitty。首先是一个单词，也就是单词开始处和结束处之间的多于一个的字母或数字(\b(\w+)\b)，然后是1个或几个空白符(\s+，最后是前面匹配的那个单词(\1)。
你也可以自己指定子表达式的组号或组名。要指定一个子表达式的组名，请使用这样的语法：(?<Word>\w+),这样就把\w+的组名指定为Word了。要反向引用这个分组捕获的内容，你可以使用\k<Word>,所以上一个例子也可以写成这样：\b(?<Word>\w+)\b\s*\k<Word>\b。

(?=exp)也叫零宽先行断言，它匹配文本中的某些位置，这些位置的后面能匹配给定的后缀exp。比如\b\w+(?=ing\b)，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如果在查找I'm singing while you're dancing.时，它会匹配sing和danc
(?<=exp)也叫零宽后行断言，它匹配文本中的某些位置，这些位置的前面能给定的前缀匹配exp。比如(?<=\bre)\w+\b会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：((?<=\d)\d{3})*\b。请仔细分析这个表达式，它可能不像你第一眼看出来的那么简单
下面这个例子同时使用了前缀和后缀：(?<=\s)\d+(?=\s)匹配以空白符间隔的数字(再次强调，不包括这些空白符)。
\b\w*q[^u]\w*\b匹配包含后面不是字母u的字母q的单词 但是如果多做测试(或者你思维足够敏锐，直接就观察出来了)，你会发现，如果q出现在单词的结尾的话，像Iraq,Benq，这个表达式就会出错。这是因为[^u]总是匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]将会匹配q后面的单词分隔符(可能是空格，或者是句号或其它的什么)，后面的\w+\b将会匹配下一个单词，于是\b\w*q[^u]\w*\b就能匹配整个Iraq fighting。负向位置指定能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。现在，我们可以这样来解决这个问题：\b\w*q(?!u)\w*\b。
零宽负向先行断言(?!exp)，只会匹配后缀exp不存在的位置。\d{3}(?!\d)匹配三位数字，而且这三位数字的后面不能是数字
同理，我们可以用(?<!exp),零宽负向后行断言来查找前缀exp不存在的位置：(?<![a-z])\d{7}匹配前面不是小写字母的七位数字
a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。
a.*?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab和ab。





























