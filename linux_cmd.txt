grep命令：
grep leo logs.log logs_back.log   //多文件查询
grep leo logs.log | grep li   //查找即包含leo又包含li的行
grep leo | li logs.log //查找匹配leo或者匹配li的行
grep leo logs.log -A2 //显示匹配行后2行
grep leo logs.log -C2 //显示匹配行前后2行
grep -i leo logs.log //不区分大小写
grep -e '[a-z]\{5\}' logs.log //使用正则表达式, a-z任意一个字符出现5次
grep -v leo logs.log //查找不包含leo的行
grep -c leo logs.log //统计包含leo的行数
grep -r leo . //遍历当前目录及所有子目录查找匹配leo的行
grep -r leo . --include "*.java"  //在当前目录及所有子目录查找所有java文件中查找leo
grep -r "hasSubstring" . --include "*.cpp" --include "*.h"  //在指定类型文件下查找
grep leo logs.log > result.log //查找并输出到指定文件
grep ^leo logs.log //查找以leo开头的行
grep leo$ logs.log //查找以leo结尾的行
grep ^$ logs.log //查找空行

grep [OPTIONS] PATTERN [FILE...]
    grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]

    OPTIONS:
    -e: 使用正则搜索
    -i: 不区分大小写
    -v: 查找不包含指定内容的行
    -w: 按单词搜索
    -c: 统计匹配到的次数
    -n: 显示行号
    -r: 逐层遍历目录查找
	-s或--no-messages   不显示错误信息
	-x或--line-regexp   只显示全列符合的列。
    -A: 显示匹配行及前面多少行, 如: -A3, 则表示显示匹配行及前3行
    -B: 显示匹配行及后面多少行, 如: -B3, 则表示显示匹配行及后3行
    -C: 显示匹配行前后多少行,   如: -C3, 则表示显示批量行前后3行
    --color: 匹配到的内容高亮显示
    --include: 指定匹配的文件类型
    --exclude: 过滤不需要匹配的文件类型
	
find命令：
 -name "文件名称"：支持使用glob
            *, ?, [], [^]
-user USERNAME：查找属主为指定用户(UID)的文件
        -group GRPNAME: 查找属组为指定组(GID)的文件
        -uidUserID：查找属主为指定的UID号的文件
        -gidGroupID：查找属组为指定的GID号的文件
        -nouser：查找没有属主的文件
        -nogroup：查找没有属组的文件
 -type TYPE:
            f: 普通文件
            d: 目录文件
            l: 符号链接文件
            s：套接字文件
            b: 块设备文件
            c: 字符设备文件
            p: 管道文件 
根据文件大小来查找：
        -size [+|-]#UNIT
            常用单位：k, M, G
            #UNIT: (#-1, #]，如：6k
            -#UNIT：[0,#-1], 如：-6k
            +#UNIT：(#,∞), 如：+6k
根据时间戳：
        -atime[+|-]#,
            #: [#,#+1)
            +#: [#+1,∞]
            -#: [0,#)
        -mtime //以“天”为单位；
        -ctime//以“天”为单位；
        -amin//以“分钟”为单位：
        -mmin以“分钟”为单位：
        -cmin以“分钟”为单位：
根据权限查找
        -perm [/|-]MODE
        MODE: 精确权限匹配
        /MODE：任何一类(u,g,o)对象的权限中只要能一位匹配即可，或关系，+ 从centos7开始淘汰
        -MODE：每一类对象都必须同时拥有指定权限，与关系
        0 表示不关注
与：-a
或：-o
非：-not, !
处理动作
    -print：默认的处理动作，显示至屏幕；
    -ls：类似于对查找到的文件执行“ls -l”命令
    -delete：删除查找到的文件；
    -flsfile：查找到的所有文件的长格式信息保存至指定文件中
    -ok COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令；
        对于每个文件执行命令之前，都会交互式要求用户确认    

    -exec COMMAND {} \; 对查找到的每个文件执行由COMMAND指定的命令
        {}: 用于引用查找到的文件名称自身

find . -name "*.c" //将目前目录及其子目录下所有延伸档名是 c 的文件列出来。
find . -type f //将目前目录其其下子目录中所有一般文件列出
find . -ctime -20 //将目前目录及其子目录下所有最近 20 天内更新过的文件列出
find /var/log -type f -mtime +7 -ok rm {} \; //查找/var/log目录中更改时间在7日以前的普通文件，并在删除之前询问它们：
find . -type f -perm 644 -exec ls -l {} \; //查找前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件
find / -type f -size 0 -exec ls -l {} \; //查找系统中所有文件长度为0的普通文件，并列出它们的完整路径
find -size -2k //查找当前目录下文件大小小与2k的文件
find /var -not -user root -not -user lp -not -user gdm|wc -l //表示查找属主不是root，lp，gdm的文件或目录

netstat命令：
netstat -a  //列出所有当前的连接
netstat -at //使用 -t 选项列出 TCP 协议的连接
netstat -au //使用 -u 选项列出 UDP 协议的连接
netstat -ant //使用 -n 选项禁用域名解析功能
netstat -tnl //使用 -l 选项列出正在监听的套接字
netstat -nlpt //使用 -p 选项查看进程信息，查看进程名和进程号
netstat -ltpe //使用 -ep 选项可以同时查看进程名和用户名，假如你将 -n 和 -e 选项一起使用，User 列的属性就是用户的 ID 号，而不是用户名
netstat -s //打印出网络统计数据，包括某个协议下的收发包数量
netstat -rn //使用 -r 选项打印内核路由信息。打印出来的信息与 route 命令输出的信息一样。我们也可以使用 -n 选项禁止域名解析。
netstat -i //-i选项打印网络接口信息
netstat -ie //将 -e 选项和 -i 选项搭配使用，显示更详细的网络接口信息
netstat -ct //-c 选项持续输出信息
netstat -g //选项 -g 会输出 IPv4 和 IPv6 的多播组信息

awk命令：
awk '{print}' testd //打印testd内的内容
df | awk '{print $5}' //打印df的信息第5列，不指定分隔符时，默认使用空格作为分隔符，$0表示显示整行，$NF表示当前行分割后的最后一列，每行的倒数第二列可以写为$(NF-1)
awk '{print $1, $2}' test //一次输出多列
df | awk '{print $4, $5, "my"}' //与自己的字段结合
BEGIN模式指定了处理文本之前需要执行的操作
END模式指定处理完所有行之后所需要执行的操作
awk 'BEGIN{print "aaa", "bbb"}' test //先执行BEGIN模式指定的打印操作，再处理test文件
awk 'BEGIN{print "aaa", "bbb"}' //不给定输入源也可以
awk 'BEGIN{print "aaa", "bbb"} {print $1, $2}' test //先执行BEGIN模式指定的动作，再执行自定义动作操作文本
awk 'BEGIN{print "aaa", "bbb"} {print $1, $2} END{print "ccc", "ddd"}' test //END在处理完所有动作之后，再执行END指定的动作
awk -F# '{print $1,$2}' test //-F选项指定#号作为输入分隔符
awk -v FS='#' '{print $1,$2}' test //-v选项指定FS变量的值作为输入分隔符
awk -v FS='#' -v OFS="+++" '{print $1,$2}' test //-v选项指定OFS变量的值作为输出分隔符
awk -v FS='#' -v OFS="+++" '{print $1 $2}' test  //不使用分隔符输出
内置变量：
$0	当前记录（作为单个变量）
$1~$n	当前记录的第n个字段，字段间由FS分隔
FS	输入字段分隔符 默认是空格
NF	当前记录中的字段个数，就是有多少列
NR	已经读出的记录数，就是行号，从1开始
RS	输入的记录他隔符默 认为换行符
OFS	输出字段分隔符 默认也是空格
ORS	输出的记录分隔符，默认为换行符
ARGC	命令行参数个数
ARGV	命令行参数数组
FILENAME	当前输入文件的名字
IGNORECASE	如果为真，则进行忽略大小写的匹配
ARGIND	当前被处理文件的ARGV标志符
CONVFMT	数字转换格式 %.6g
ENVIRON	UNIX环境变量
ERRNO	UNIX系统错误消息
FIELDWIDTHS	输入字段宽度的空白分隔字符串
FNR	当前记录数
OFMT	数字的输出格式 %.6g
RSTART	被匹配函数匹配的字符串首
RLENGTH	被匹配函数匹配的字符串长度
SUBSEP	\034

gdb调试：
strace -p pid  //附着到一个已经在跑的进程上， 实时观察进程
gdb attach pid //附着到这个已经存在的进程
set args 可指定运行时参数。（如：set args 10 20 30 40 50 ）
show args 命令可以查看设置好的运行参数
run (r) 启动程序
不指定运行参数 r
指定运行参数r 10 20 30 40 50
nfo terminal 显示你程序用到的终端的模式。
使用重定向控制程序输出。如：run > outfile
break 设置断点，可以简写为b
b 10 设置断点，在源程序第10行
b func 设置断点，在func函数入口处
break filename:linenum 在源文件filename的linenum行处停住 
break filename:function 在源文件filename的function函数的入口处停住
break class::function或function(type,type) 在类class的function函数的入口处停住
break namespace::class::function在名称空间为namespace的类class的function函数的入口处停住

break linespec thread threadno
break linespec thread threadno if …  //linespec指定了断点设置在的源程序的行号。threadno指定了线程的ID，注意，这个ID是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你不指定‘thread threadno ’则表示你的断点设在所有线程上面。你还可以为某线程指定断点条件。如
info threads
thread ID 来切换
set scheduler-locking off|on|step 估计实际使用过多线程调试的人都可以发现，
在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，
怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。
off 不锁定任何线程，也就是所有线程都执行，这是默认值。 
on 只有当前被调试程序会执行。 
设置 on 之后， step 在单步的时候， 只有当前线程会执行。

set follow-fork-mode parent 跟踪父进程, 默认
set follow-fork-mode child  跟踪子进程

info b //查询所有断点
watch 为表达式（变量）expr设置一个观察点。当表达式值有变化时，马上停住程序。
rwatch 表达式（变量）expr被读时，停住程序。
awatch 表达式（变量）的值被读或被写时，停住程序
info watchpoints 列出当前所设置了的所有观察点。
一般来说，为断点设置一个条件，我们使用if关键词，后面跟其断点条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。并且，条件设置好后，我们可以用condition命令来修改断点的条件。（只有break 和 watch命令支持if，catch目前暂不支持if）。
b test.c:8 if intValue == 5 //设置一个条件断点
condition 与break if类似，只是condition只能用在已存在的断点上
condition bnum expression //修改断点号为bnum的停止条件为expression
condition bnum //清楚断点号为bnum的停止条件
ignore 忽略停止条件几次
ignore bnum count //表示忽略断点号为bnum的停止条件count次
clear 清除所有的已定义的停止点
clear function 清除所有设置在函数上的停止点
clear linenum 清除所有设置在指定行上的停止点。
clear filename:linenum 清除所有设置在指定文件：指定行上的停止点。
delete [breakpoints] [range...] 删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为d。比删除更好的一种方法是disable停止点，disable了的停止点，GDB不会删除，当你还需要时，enable即可，就好像回收站一样。
disable [breakpoints] [range...] disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis.
enable [breakpoints] [range...] enable所指定的停止点，breakpoints为停止点号
enable [breakpoints] once range… enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable
enable [breakpoints] delete range… enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。
//为断点号bnum指写一个命令列表。当程序被该断点停住时，gdb会依次运行命令列表中的命令
commands [bnum]
… command-list …
end

run 运行程序，可简写为r
next 单步跟踪，函数调用当作一条简单语句执行，可简写为n
step 单步跟踪，函数调进入被调用函数体内，可简写为s
finish 退出函数
until 在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体,可简写为u。
fin: step out， 跳出函数
continue 继续运行程序，可简写为c
stepi或si, nexti或ni 单步跟踪一条机器指令,一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令
info program 来查看程序的是否在运行，进程号，被暂停的原因。
help i //查询info详情

p ‘f2.c’::x  //查看文件f2.c中的全局变量x的值
p *array@len //显示出这个动态数组的取值,@的左边是数组的首地址的值，也就是变量array所指向的内容，右边则是数据的长度，其保存在变量len中
你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是display
x/<n/f/u> <addr>
n、f、u是可选的参数。
n是一个正整数，表示显示内存的长度，也就是说从当前地址向后显示几个地址的内容。
f 表示显示的格式，参见上面。如果地址所指的是字符串，那么格式可以是s，如果 地址是指令地址，那么格式可以是i。
u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes。u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。
<addr>表示一个内存地址
命令：x/3uh 0x54320 表示，从内存地址0x54320读取内容，h表示以双字节为一个单位，3表示三个单位，u表示按十六进制显示。
x 按十六进制格式显示变量。
d 按十进制格式显示变量。
u 按十六进制格式显示无符号整型。
o 按八进制格式显示变量。
t 按二进制格式显示变量。
a 按十六进制格式显示变量。
c 按字符格式显示变量。
f 按浮点数格式显示变量。

display expr
display/fmt expr
display/fmt addr
expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值

print x=4 //修改变量的值
set var width=47
jump linespec  //指定下一条语句的运行点, 可以是文件的行号，可以是file:line格式，可以是+num这种偏移量格式。表示下一条运行语句从哪里开始
jump *address //代码行的内存地址
signal signal //产生一个信号量给被调试的程序，
return
return expression //如果你的调试断点在某个函数中，并还有语句没有执行完。你可以使用return命令强制函数忽略还没有执行的语句并返回, 使用return命令取消当前函数的执行，并立即返回，如果指定了，那么该表达式的值会被认作函数的返回值
call expr
print expr //强制调用函数的目的,并显示函数的返回值
list //显示源代码
set listsize count //设置一次显示源程序的行数
show listsize //查看当前listsize的设置

frame addr  //查看pc地址为addr的桢的相关信息
info signals //查看有哪些信号在被GDB检测中
catch //当event发生时，停住程序。event可以是下面的内容： 
1、throw 一个C++抛出的异常。（throw为关键字） 
2、catch 一个C++捕捉到的异常。（catch为关键字）

默认编译的时候，调试过程是看不见宏的值的。编译时候需要给选项。-g3
gcc  -g3 -o test.c  test
macro expand macroname(...) 查看展开形式
还可以用info macro macroname 查看宏定义。

layout：用于分割窗口，可以一边查看代码，一边测试。主要有以下几种用法：
layout src：显示源代码窗口
layout asm：显示汇编窗口
layout regs：显示源代码/汇编和寄存器窗口
layout split：显示源代码和汇编窗口
layout next：显示下一个layout
layout prev：显示上一个layout
Ctrl + L：刷新窗口
Ctrl + x，再按1：单窗口模式，显示一个窗口
Ctrl + x，再按2：双窗口模式，显示两个窗口
Ctrl + x，再按a：回到传统模式，即退出layout，回到执行layout之前的调试窗口。


tcpdump命令：
tcpdump -i  eth0  -nnX  port  21
tcpdump采用命令行方式对接口的数据包进行筛选抓取，其丰富特性表现在灵活的表达式上。不带任何选项的tcpdump，默认会抓取第一个网络接口，且只有将tcpdump进程终止才会停止抓包。
例如：tcpdump -nn -i eth0 icmp
tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]
        [ -s snaplen ] [ -w file ] [ expression ]
抓包选项：
-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定"-c 10"将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。
-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)，
            ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用'any'关键字表示所有网络接口。
-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。
-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。
-N：不打印出host的域名部分。例如tcpdump将会打印'nic'而不是'nic.ddn.mil'。
-P：指定要抓取的包是流入还是流出的包。可以给定的值为"in"、"out"和"inout"，默认为"inout"。
-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断，
      ：输出行中会出现"[|proto]"的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，
      ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。
输出选项：
-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。
-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。
-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。
-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。
-v：当分析和打印的时候，产生详细的输出。
-vv：产生比-v更详细的输出。
-vvv：产生比-vv更详细的输出。
其他功能性选项：
-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于"-i"后。
-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。
-w：将抓包数据输出到文件中而不是标准输出。可以同时配合"-G time"选项使得输出文件每time秒就自动切换到另一个文件。可通过"-r"选项载入这些文件以进行分析和打印。
-r：从给定的数据包文件中读取数据。使用"-"表示从标准输入中读取。


tar命令
功能说明：用来建立，还原备份文件的工具程序，它可以加入，解开备份文件内的文件
-c: 建立压缩档案
-x：解压
-t：查看内容
-r：向压缩归档文件末尾追加文件
-u：更新原压缩包中的文件
这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。
-z：有gzip属性的
-j：有bz2属性的
-Z：有compress属性的
-v：显示所有过程
-O：将文件解开到标准输出
下面的参数-f是必须的
-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。

--exclude：用来排除某些目录和文件，目录最后的/不要


curl命令：
url命令是一个功能强大的网络工具，它能够通过http、ftp等方式下载文件，也能够上传文件。其实curl远不止前面所说的那些功能，大家可以通过man curl阅读手册页获取更多的信息。类似的工具还有wget。curl命令使用了libcurl库来实现，libcurl库常用在C程序中用来处理HTTP请求，curlpp是libcurl的一个C++封装，这几个东西可以用在抓取网页、网络监控等方面的开发，而curl命令可以帮助来解决开发过程中遇到的问题。
-v/--verbose 小写的v参数，用于打印更多信息，包括发送的请求信息，这在调试脚本是特别有用。
-m/--max-time <seconds> 指定处理的最大时长
-H/--header <header> 指定请求头参数
-s/--slient 减少输出的信息，比如进度
--connect-timeout <seconds> 指定尝试连接的最大时长
-x/--proxy <proxyhost[:port]> 指定代理服务器地址和端口，端口默认为1080
-o/--output <file> 指定输出文件名称
-d/--data/--data-ascii <data> 指定POST的内容
--retry <num> 指定重试次数
-e/--referer <URL> 指定引用地址
-I/--head 仅返回头部信息，使用HEAD请求











