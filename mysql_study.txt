create table emp(ename varchar(10), hiredate date, sal decimal(10, 2), deptno int(2));
insert into dept values(5, 'dept5'), (6, 'dept6');
update emp set sal=4000 where ename='lisa';
update emp a, dept b set a.sal=a.sal*b.deptno, b.deptname=a.ename where a.deptno = b.deptno;
delete from emp where ename='dony';
delete a, b from emp a, dept b where a.deptno=b.deptno and a.deptno=1;
select ename, hiredate, sal, deptno from emp;
select * from emp where deptno=1;
select * from emp where deptno=1 and sal < 3000;
select * from emp order by sal limit 3;
select * from emp order by deptno, sal desc;
select * from emp order by sal limit 1, 3;
select count(1) from emp;
select deptno, count(1) from emp group by deptno;
select deptno, count(1) from emp group by deptno with rollup;
select deptno, count(1) from emp group by deptno having count(1)>1;
select sum(sal), max(sal), min(sal) from emp;
select ename, deptname from emp,dept where emp.deptno=dept.deptno;
select ename, deptname from emp left join dept on emp.deptno=dept.deptno;
select ename, deptname from dept right join emp on dept.deptno=emp.deptno;
select * from emp where deptno in(select deptno from dept);
select * from emp where deptno = (select deptno from dept limit 1);
select emp.* from emp, dept where emp.deptno=dept.deptno;
select deptno from emp union all select deptno from dept;


alter table t1 modify id1 int zerofill;
alter table t1 modify id2 int(5) zerofill;

CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(ID));
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, UNIQUE(ID));

CREATE TABLE t1 (
	id1 float(5, 2) default NULL,
	id2 double(5, 2) default NULL,
	id3 decimal(5, 2) default NULL
);

alter table t add id2 timestamp;
show create table t;

select length(v), length(c) from vc;

create database test1;
use mysql


create table t (gender enum('M', 'F'));

select 1=0, 1=1, NULL=NULL;

create table ai (
	i bigint(20) not null auto_increment,
	primary key (i)
) engine=myisam default charset=gbk;

create table country (
	country_id smallint unsigned not null auto_increment,
	country varchar(50) not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (country_id)
) engine=InnoDB default charset=utf8;

alter table ai engine = innodb;

create table city (
	city_id smallint unsigned not null auto_increment,
	city varchar(50) not null,
	country_id smallint unsigned not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (city_id),
	key idx_fk_country_id (country_id),
	constraint 'fk_city_country' foreign key (country_id) references country (country_id) on delete restrict on update cascade
) engine=InnoDB default charset=utf8;

create table tab_memory engine=memory
	select city_id, city, country_id	
	from city group by city_id;

67

/*高级查询*/
select 选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制;
select选项：系统该如何对待查询得到的结果
all:默认的，表示保存所有的记录
-- select选项
select all * from my_simple; --select *;
select distinct * from my_simple;
distinct:去重，去除重复的记录，只保留一条（所有的字段都相同）
字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段全名成不同名的：别名alias
基本语法：字段名[as]别名
select distinct name as name1, name name2 from my_simple;

from数据源
from是为前面的查询提供数据：数据源只要是一个符合二维表结构的数据即可
单表数据
from表名；
多表数据
从多表获取数据，基本语法：from表1， 表2。。。
结果：两张表的记录数相乘，字段数拼接
本质：从第一张表取出一条记录，去接着第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的廉洁：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义：应该尽量避免出现笛卡尔积。

动态数据：
from 后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。
基本语法：from select 字段列表 from 表）as 
select * from (select int_1, int_8 from my_int) as int_my;

where子句
用来从数据表获取数据的时候，进行条件筛选。
数据获取原理：针对表去对应的磁盘获取所有的记录（一条条），where的作用就是在拿到一条结果就开始进行判断，判断是否符合，如果符合就保存下来，如果不符合直接舍弃（不放到内存中）
where是通过运算符进行结果比较来判断数据

group by字句
表示分组的含义：根据指定的字段，将数据进行分组：分组的目标是为了统计
分组统计
group by 字段名；
create table my_student (std_id varchar(10), stu_name varchar(10)) charset=gbk;
insert into my_student values('stu0001', '夏洛');
alter table my_student add class_id int;
update my_student set class_id = 1 where std_id in('stu0001', 'stu0002');
alter table my_student change column std_id stu_id varchar(10);

分组 
select * from my_student group by class_id; --根据班级id进行分组

group by是为了分组后进行数据统计的，如果只是想看数据显示，那么group by没什么含义：group by将数据按照指定的字段分组之后，只会保留每组的第一条记录。
利用一些统计函数：（聚合函数）
count()：统计每组中的数量，如果统计目标是字段，那么不统计为空NULL字段，如果为*那么代表统计记录
alter table my_student add stu_age tinyint unsigned;
update my_student set stu_age = 18, stu_height = 185 where stu_id = 'stu0001'; 
select class_id, count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
select class_id, group_concat(stu_name), count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
avg():求平均值
sum():求后
max():求最大值
min():求最小值
group_concat():为了将分组中指定的字段进行合并（字符串拼接）

多分组
将数据探明某个字段进行分组之后，对已经分组的数据进行再次分组
基本语法：group by 字段1,字段2;//先探明字段1进行排序，之后将结果再按照字段2进行排序
alter table my_student add gender enum('男', '女', '保密');
update my_student set gender = 1 where stu_id in ('stu0001', 'stu0003');
insert into my_student values('stu0005', '小猪', 1, 30, 173, 2);
-- 多分组
select class_id, gender, count(*), group_concat(stu_name) from my_student group by class_id, gender;

分组排序
mysql中，分组默认有排序的功能：按照分组字段进行排序，默认是升序
基本语法：group by 字段[asc|desc], 字段[asc|desc]
select class_id, gender, count(*), group_concat(stu_name) from my_student group by class_id asc, gender desc;

回溯统计
当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称为回溯统计：每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL。
基本语法：group by 字段 [asc|desc]with rollup;
select class_id, count(*) from my_student group by class_id with rollup;
select class_id, gender, count(*) from my_student group by class_id, gender with rollup;

having子句
having的本质和where一样，是用来进行数据条件筛选。
having是在group by子句之后，可以针对分组数据进行统计，但是where不行。
where不能使用聚合函数：聚合函数是用在group by分组的时候，where已经运行完毕。
having 在group by分组之后，可以使用聚合函数或者字段别名（where是从表中取出数据，别名是在数据进入到内存之后才有的）
create table my_student (std_id varchar(10), stu_name varchar(10), class_id tinyint, stu_age tinyint, stu_height tinyint, gender enum('男', '女', '保密')) charset=gbk;
alter table my_student change stu_height stu_height tinyint unsigned;
insert into my_student values('stu0007', '小江', 1, 25, 178, 2);
select class_id, count(*) as number from my_student group by class_id having number >= 4;
强调：having是在group by之后，group by是在where之后，where的时候表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作。

order by排序：根据校对规则对数据进行排序
基本语法：order by 字段 [asc|desc] //asc升序 desc降序
select * from my_student order by stu_height asc;
order by也可以像group by一新进行多字段排序：先按照第一个字段进行排序，然后再按照第二个字段进行排序。
order by 字段1 规则，字段2 规则 
-- 按照班级以及身高排序
select * from my_student order by class_id desc, stu_height;

limit子句
limit限制子句：主要是用来限制记录数量获取
记录数限制
纯粹的限制获取的数量，从第一条到指定的数量
基本语法：limit 数量;
select * from my_student limit 2;
limit通常在查询的时候如果限定为一条记录的时候，使用的比较多：有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力。

分页
利用limit来限制获取指定区间的数据
基本语法：limit offset length; //offset偏移量：从哪开始，length就是具体的获取多少条记录
mysql中记录的数量从0开始
limit 0,2;表示获取前两条记录。
-- 分页获取数据
select * from my_student limit 1, 2;
注意：limit后面的length表示最多获取对应数量，但是如果数量不够，系统不会强求。

查询中的运算符
算术运算符
+、-、*、/、%
基本算术运算：通常不在条件中使用，而是用于结果运算(select 字段中)
create table ysf1(int_1 int, int_2 int, int_3 int, int_4 int)charset utf8;
insert into ysf1 values(100, -100, 0, default);
-- 算术运算
select int_1 + int_2, int_1 - int_2, int_1 * int_2, int_1 / int_2, int_2 / int_3, int_2 % 6, int_4 % 5 from ysf1;

比较运算符
> >= < <= = <>
通常是用来在条件中进行限定结果
=：在mysql中，没有对应==比较符号，就是使用=来进行相等判断
<=>:相等比较
特殊应用：就是在字段结果中进行比较运算
mysql中没有规定select必须有数据表
select '1' <=> 1, 0.02 <=> 0;
在条件判断的时候，还有对应比较运算符：计算区间
select * from my_student where stu_age between 20 and 30;
between中条件1必须小于条件2，反过来不可以
时间比较：
select * from t_cts_txs_send where txState = 6 and createTime > '20190410' and uid = 25 limit 100;
select * from t_cts_txs_send where modifyTime > '2019-04-11 14:10:00' and uid = 25 limit 100;

逻辑运算符
and or not
and:逻辑与
or:逻辑或
not:逻辑非
select * from my_student where stu_age >= 20 and stu_age <= 30;

in运算符
in:在什么里面，是用来替代=，当结果不是一个值，而是一个结果集的时候
基本语法：in（结果1， 结果2，结果3.。。），只要当前条件在结果集中出现过，那么就成立
select * from my_student where std_id in ('stu0001', 'stu0004', 'stu0007');

is运算符
is是专门用来判断字段是否为NULL的运算符
基本语法：is null/is not null
select * from my_int where int_6 is null;

like运算符
like运算符：是用来进行模糊匹配（匹配字符串）
基本语法：like匹配模式
匹配模式中，有两种占位符：
_：匹配对应的单个字符
%：匹配多个字符
select * from my_student where stu_name like '小%';

联合查询
联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。
联合查询：将多个查询的结果合并到一起（纵向合并）：字段数不变，多个查询的记录数合并
应用块景
1.将同一张表中不同的结果（需要对应金条查询语句来实现），合并到一起展示数据。
2.最常见：在数据量大的情况下，会对表进行分表操作，需要对每张表进行部分数据统计，使用联合查询来将数据存放到一起显示。
基本语法:
select语句
union [union 选项]
select 语句；
union选项：与select选项基本一样
distinct:去重，去掉完全重复的数据（默认的）
all:保存所有的结果
(select * from my_student where gender = '男' order by stu_height asc limit 10)
union
(select * from my_student where gender = '女' order by stu_height desc limit 10);
注意细节：union理论上只要保证字段数一样，不需要每次拿到的数据对应的字段类型一致。永远只保留第一个select语句对应的字段名字。

order by的使用
2. 在联合查询中，如果要使用order by,那么对应select语句必须配合使用limit：而limit后面必须跟对应的限制数量（通常可以使用一个较大的值：大于对应表的记录数）

连接查询
将多张表连到一起进行查询（会导致记录数行和字段数列发生改变）
连接查询的意义
在关系型数据库设计过程中，实体（表）与实体之间是存在很多联系的。在关系型数据库表的设计过程中，遵循着关系来设计：一对一，一对多和多对多，通常在实际操作的过程中，需要利用这层关系来保证数据的完整性。
连接查询分类
连接查询一共有以下几类
交叉连接
内连接
外连接：左外连接（左连接）和右外连接（右连接）
自然连接

交叉连接
将两张表的数据与另外一张表彼此交叉
原理
1.从第一张表依次取出每一条记录
2.取出每一条记录之后，与另外一张表的全部记录挨个匹配
3.没有任何匹配条件，所有的结果都会进行保留
4.记录数=第一张表记录数 * 第二张表记录数；字段数 = 第一张表字段数 + 第二张表字段数（笛卡尔积）
语法
基本语法：表1 cross join 表2
select * from my_student cross join my_int;
应用
交叉连接产生的结果是笛卡尔积，没有实际应用。
本质：from 表1,表2；

内连接
inner join,从一张表中取出所有的记录去另外一张表中匹配：利用匹配条件进行匹配，成功了则保留，失败了放弃。
原理
1.从第一张表中取出一条记录，然后去另外一张表中进行匹配
2.利用匹配条件进行匹配
2.1 匹配到：保留，继续向下匹配
2.2 匹配失败：向下继续，如果全表匹配失败，结束
语法
基本语法：表1[inner]join 表 2 on 匹配条件；
create table my_class( id int primary key auto_increment, name varchar(10) not null unique)charset utf8;
insert into my_class values(null, '1班'), (null, '2班'), (null, '3班');
select * from my_student inner join my_class; -- 可以，没有条件，笛卡尔积
1.如果内连接没有条件（允许），那么其实就是交叉连接（避免）
2.使用匹配条件进行匹配
select * from my_student inner join my_class on class_id = id;
3.因为表的设计通常容易产生同名字段，尤其是ID，所以为了避免重名出现错误，通常使用表名.字段名，来确保唯一性
select * from my_student inner join my_class on my_student.class_id = my_class.id;
4.通常，如果条件中使用到对应的表名，而表名通常比较长，所以可以通过表别名来简化
select * from my_student as s inner join my_class c on s.class_id = c.id;
5.内连接匹配的时候，必须保证匹配到都会去保存
select * from my_class c inner join my_student as s on  s.class_id = c.id;
6.内连接因为不强制必须使用匹配条件(on)因此可以在数据匹配完成之后，使用where条件来限制，效果与on一样（建议使用on）
select * from my_class c inner join my_student as s where  s.class_id = c.id;
应用
内连接通常是在对数据有精确要求的地方使用：必须保证两种表中都能进行数据匹配。

外连接
outer join，按照某一张表作为主表（表中所有记录在最后都会保留），根据条件去连接另外一张表，从而得到目标数据。
外连接分为两种：左外连接(left join)，右外连接(right join)
左连接：左表是主表
右连接：右表是主表
原理
1.确定连接主表：左连接就是left join左边的表为主表；right join右边为主表
2.拿主表的每一条记录，去匹配另外一张表（从表）的每一条记录
3.如果满足匹配条件：保留；不满足不保留
4.如果主表记录在从表中一条都没有匹配成功，那么也要保留该记录：从表对应的字段值都为NULL
语法
基本语法：
左连接：主表left join 从表 on 连接条件
右连接：从表right join 主表 on 连接条件
左连接对应的主表数据在左边；右连接对应的主表数据在右边：
select * from my_student as s left join my_class c on s.class_id = c.id;
select * from my_student as s right join my_class c on s.class_id = c.id;
特点
1.外连接中主表数据记录一定会保存：连接之后不会出现记录数少于主表（内连接可能）
2.左连接和右连接其实可以互相转换，但是数据对应的位置（表顺序）会改变
应用
非常常用的一种获取数据方式：作为数据获取对应主表以及其它数据（关联）

using关键字
是在连接查询中用来代替对应的on关键字的，进行条件匹配
原理
1.在连接查询时，使用on的地方用using代替
2.使用using的前提是对应的两张表连接的字段是同名（类似自然连接自动匹配）
3.如果使用using关键字，那么对应的同名字段，最终在结果中只会保留一个。
语法
基本语法：表1[inner,left,right]join 表2 using(同名字段列表);//连接字段
select * from my_student left join my_class using(class_id);

子查询
子查询是一种常用计算机语言SELECT-SQL语言中嵌套查询下层的程序模块。当一个查询是另一个查询的条件时，称之为子查询。
子查询：指在一条select语句中，嵌入了另外一条select语句，那么被嵌入的select语句称之为子查询语句。
主查询概念
主查询：主要的查询对象，第一条select语句，确定的用户所有获取的数据目标（数据源），已经要具体得到的字段信息。
子查询和主查询的关系
1.子查询是嵌入到主查询中的；
2.子查询是辅助主查询的：要么作为条件，要么作为数据源
3.子查询其实可以独立存在：是一条完整的select语句
子查询分类
按功能分
标量子查询：子查询返回的结果是一个数据（一行一列）
语法
基本语法：select * from 数据源 where条件判断 =/<>(select 字段名 from 数据源 where 条件判断);//子查询得到的结果只有一个值
-- 知道一个学生的名字：小猪，想知道他在哪个班级（班级名字）
-- 1.通过学生表获取他所在班级ID
-- 2.通过班级ID获取班级名字
-- 标量子查询实现
select * from my_class where id = (select class_id from my_student where stu_name = '小猪');
列子查询：返回的结果是一列（一列多行）
语法：主查询 where 条件 in（列子查询）;
-- 想获取已经有学生在班的所有班级名字；
-- 1.找出学生表中所有的班级ID
-- 2.找出班级表中对应的名字
-- 列子查询实现
select name from my_class where id in (select distinct class_id from my_student);
行子查询：返回的结果是一行（一行多列）
行元素：字段元素是指一个字段对应的值，行元素对应就是多个字段：多个字段合起来作为一个元素参与运算，把这种情况称之为行元素。
语法：主查询 where 条件[(构造一个行元素)] = (行子查询);
-- 需求：获取班级上年龄，且身高最高的学生
-- 1.求出班级年龄最大的值
-- 2.求出班级身高最高的值
-- 3.求出对应的学生
select * from my_student where (stu_age, stu_height) = (select max(stu_age), max(stu_height) from my_student);
总结：已经学过三个子查询：常见的三个子查询
标题子查询，列子查询和行子查询：都属于where子查询
表子查询：返回的结果是多行多列（多行多列）
表子查询与行子查询非常相似，只是行子查询需要产生行元素，而表子查询没有。
行子查询是用于where条件判断：where子查询
表子查询是用于from数据源:from子查询
语法：select 字段表 from (表子查询)[where][group by][having][order by][limit];
-- 获取每个班上身高最高的学生（一个）
select * from my_student group by class_id having stu_height = max(stu_height);（错误）
-- 1.将每个班最高的学生排在最前面：order by
-- 2.再针对结果进行group by:保留每组第一个
select * from (select * from my_student order by stu_height desc) as temp group by class_id;
exists子查询：返回的结果1或者0（类似布尔操作）1代表成立，0代表不成立
语法：where exists(查询语句);//exists就是根据查询得到的结果进行判断：如果结果存在，那么返回1，否则返回0
where 1：永远为真
-- 求出，有学生在的所有班级
select * from my_class as c where exists(select stu_id from my_student as s where s.class_id = c.id);
按位置分
where子查询：子查询出现的位置在where条件中
from子查询：子查询出现的位置在from数据源中（做数据源）

子查询中特定关键字的使用
in:主查询 where 条件 in (列子查询);
any:=any(列子查询):条件在查询结果中有任意一个匹配即可，等价于in
<>any(列子查询):条件在查询结果中不等于任意一个
1 =any(1,2,3) =====true
1 <>any(1,2,3) =====true
some
与any完全一样
all
=all(列子查询):等于里面所有
<>all(列子查询):不等于里面所有
select * from my_class where id =all(select class_id from my_student);
select * from my_class where id <>all(select class_id from my_student);
select * from my_class where id <>any(select class_id from my_student);
如果对应的匹配字段有NULL，那么不参与匹配


整库数据备份与还原
整库数据备份也叫SQL数据备份：备份的结果都是SQL指令
在mysql中提供了一个专门用于备份SQL的客户端：mysqldump.exe
应用场景
SQL备份是一种mysql非常常见的备份与还原方式，SQL备份不只是备份数据，还备份对应的SQL指令（表结构）：即便是数据库遭到毁灭性破坏（数据库被删），那么利用SQL备份依然可以实现数据还原。
SQL备份因为需要备份结构，因此产生的备份文件特别大，因此不适合特大型数据备份，也不适合数据变换频繁型数据库备份。
应用方案
SQL备份 
SQL备份用到的是专门的备份客户端，因此还没与数据库服务器进行连接。
基本语法：mysqldump/mysqldump.exe -hPup 数据库名字[表1 [表2...]] > 备份文件地址
备份可以有三种形式：
1.整库备份（只需要提供数据库名字）
mysqldump.exe -hlocalhost -P3306 -uroot -p123456 test1 > E:\study\mysql\temp\test1.sql
2.单表备份：数据库后面跟一张表
3.多表备份：数据库后跟多张表
mysqldump -uroot -p123456 test1 my_class my_student > E:\study\mysql\temp\tables_class_student.sql
数据还原
mysql提供了多种方式来实现：两种
mysqldump备份的数据中没有关于数据库本身的操作，都是针对表级别的操作：当进行数据（SQL还原），必须指定数据库
1.利用mysql.exe客户端：没有登录之前，可以直接用该客户端进行数据还原
mysql.exe -hPup 数据库 < 文件位置
2.在SQL指令，提供了一种导入SQL指令的方式
source SQL文件位置 //必须先进入到对应的数据库
3.人为操作：打开备份文件，复制所有SQL指令，然后执行。

用户权限管理
在不同的项目中给不同的角色（开发者）不同的操作权限，为了保证数据库数据的安全。

外键
外键概念
外键：foreign key
一张表(A)中有一个字段，保存的值指向另外一张表(B)中的主键
B:主表
A:从表
外键的操作
mysql中提供了两种方式增加外键
1.方案1：在创建表的时候增加外键（类似主键）
基本语法：在字段之后增加一条语句
[constraint `外键名`]foreign key(外键字段)references 主表(主键);
2.方案2：在创建表后增加外键
alter table 从表 add constraint `外键名`]foreign key(外键字段)references 主表(主键);
create table my_foreign(id int primary key auto_increment, name varchar(10) not null, class_id int, foreign key(class_id) references my_class(id))charset utf8;
MUL:多索引，外键本身是是一个索引，外键要求外键字段本身也是一种普通索引。 
修改&删除外键
外键不允许修改，只能先删除后增加
基本语法：alter table 从表 drop foreign key 外键名字
alter table my_student drop foreign key `student_class_ibfk_1`;
外键不能删除产生的普通索引，只会删除外键自己
如果想删除
如果想删除对应的索引：alter table 表名 drop index 索引名字;

外键基本要求
1.外键字段需要保证与关联的主表的主键字段类型完全一致
2.基本属性也要相同
3.如果是在表后增加外键，对数据还有一定的要求（从表数据与主表的关联关系）
4.外键只能使用innodb存储引擎，myisam不支持

外键约束
通过建立外键关系之后，对主表和从表都会有一定的数据约束效率
约束的基本概念
当一个外键产生时，外键所在的表（从表）会受制于主表数据的存在从而导致数据不能进行某些不符合规范的操作（不能插入主表不存在的数据）；
2.如果一张表被其他表外键引入，那么该表的数据操作就不能随意：必须保证从表数据的有效性（不能随便删除一个被从表引入的记录）
insert into my_foreign values(null, '小明', 1); -- 正确
insert into my_foreign values(null, '小李', 4); -- 不正确（主表没有该记录）
外键约束的概念
可以在创建外键的时候，对外键约束进行选择性的操作。
基本语法： add foreign key(外键字段)references 主表(主键) on 约束模式
约束模式有三种：
1.distinct 严格模式：默认的，不允许操作
2.cascade:级联模式，一起操作，主表变化，从表数据跟着变化
3.set null:置空模式，主表变化（删除），从表对应记录设置为空，前提是从表中的对应的外键字段允许为空
外键约束主要约束的对象是主表操作，从表就是不能插入主表不存在的数据
通常在进行约束的时候，需要指定操作：update 和 delete
常用的约束模式：on update cascade, on delete set null, 更新级联，删除置空
alter table my_student add foreign key(class_id) references my_class(class_id)
-- 约束
on update cascade on delete set null;
-- 更新主表
update my_class set class_id = 4 where class_id = 2;

约束作用
保证数据的完整性：主表与从表的数据要一致
正是因为外键非常强大的数据约束作用，而且可能导致数据在后台变化的不可控。导致程序在进行设计开发逻辑的时候，没有办法去很好的把握数据（业务），所以外键比较少使用。

视图基本操作
创建视图
视图本质是SQL指令
基本语法：create view 视图名字 as select 指令；//可以是单表数据，也可以是连接查询，联合查询或者子查询
create view student_class_v as
select s.*, c.name from my_student as s left join
my_class as c
on
s.class_id = c.class_id;
查看视图结构：视图本身是虚拟表，所以关于表的一些操作都适用于视图
使用视图
视图是一张虚拟表，可以直接把视图当做“表”操作，但是视图本身没有数据，是临时执行select语句得到对应的结果。视图主要用于查询操作。

修改视图
本质是修改视图对应的查询语句
alter view 视图名字 as 新 select语句;

删除视图
基本语法：drop view 视图名字;

事务安全
事务概念
事务(transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。事务通常由高级数据库操纵语文或编程语文书写的用户程序的执行所引起。事务由事务开始（begin transaction）和事务结束（end transaction）之间执行的全体操作组成。
事务基本原理
mysql允许将事务统一进行管理（存储引擎INNODB），将用户所做的操作，暂时保存起来，不直接放到数据表（更新），等到用户确认结果之后再进行操作。
事务在mysql中通常是自动提交的，但是也可以使用手动事务

自动事务：autocommit，当客户端发送一条SQL指令（写操作：增删改）结服务器的时候，服务器在执行之后，不用等待用户反馈结果，会自动将结果同步到数据表。
证明：
自动事务：系统做了额外的步骤来帮助用户操作，系统是通过变量来控制的。autocommit
show variables like 'autocommit%';
关闭自动事务：关闭之后系统就不在帮助用户提交结果了。
set autocommit = off;
一旦自动事务关闭，那么需要用户提供是否同步的命令
commit;提交（同步到数据表）
rollback：回滚（清空之前的操作，不要了）；
事务没有提交的对比查看：在执行事务端的客户端中，系统在进行数据查看的时候会利用事务日志中保存的结果对数据进行加工。
通常：我们不会关闭自动事务，这样操作太麻烦。因此只会在需要使用事务处理的时候，才会进行操作（手动事务）

手动事务：不管是开始还是过程还是结束都需要用户（程序员），手动的发送事务操作指令来实现。
手动事务对应的命令
1.start transaction;//开启事务：从这条语句开始，后面的所有语句都不会直接写入到数据表（保存在事务日志中）
2.事务处理：多个写指令构成
3.事务提交：commit/rollback,到这个时候所有的事务才算结束
start transaction;
将多个连续的但是是一个整体的SQL指令，逐一执行
commit;

回滚点
savepoint,当有一系列事务操作时，而其中的步骤如果成功了，没有必要重新来过，可以在某个点（成功），设置一个记号（回滚点），如果后面有失败，可以回到这个记号位置。
增加回滚点：savepoint回滚点名字；//字母数字和下划线构成
回到回滚点：rollback to 回滚点名字；//回滚点之后的所有操作没有了
注意：在一个事务处理中，可以设置多个回滚点。如果回到了前面的回滚点，后面的回滚点就失效













