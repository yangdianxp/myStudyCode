create table emp(ename varchar(10), hiredate date, sal decimal(10, 2), deptno int(2));
insert into dept values(5, 'dept5'), (6, 'dept6');
update emp set sal=4000 where ename='lisa';
update emp a, dept b set a.sal=a.sal*b.deptno, b.deptname=a.ename where a.deptno = b.deptno;
delete from emp where ename='dony';
delete a, b from emp a, dept b where a.deptno=b.deptno and a.deptno=1;
select ename, hiredate, sal, deptno from emp;
select * from emp where deptno=1;
select * from emp where deptno=1 and sal < 3000;
select * from emp order by sal limit 3;
select * from emp order by deptno, sal desc;
select * from emp order by sal limit 1, 3;
select count(1) from emp;
select deptno, count(1) from emp group by deptno;
select deptno, count(1) from emp group by deptno with rollup;
select deptno, count(1) from emp group by deptno having count(1)>1;
select sum(sal), max(sal), min(sal) from emp;
select ename, deptname from emp,dept where emp.deptno=dept.deptno;
select ename, deptname from emp left join dept on emp.deptno=dept.deptno;
select ename, deptname from dept right join emp on dept.deptno=emp.deptno;
select * from emp where deptno in(select deptno from dept);
select * from emp where deptno = (select deptno from dept limit 1);
select emp.* from emp, dept where emp.deptno=dept.deptno;
select deptno from emp union all select deptno from dept;


alter table t1 modify id1 int zerofill;
alter table t1 modify id2 int(5) zerofill;

CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(ID));
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, UNIQUE(ID));

CREATE TABLE t1 (
	id1 float(5, 2) default NULL,
	id2 double(5, 2) default NULL,
	id3 decimal(5, 2) default NULL
);

alter table t add id2 timestamp;
show create table t;

select length(v), length(c) from vc;

create database test1;
use mysql


create table t (gender enum('M', 'F'));

select 1=0, 1=1, NULL=NULL;

create table ai (
	i bigint(20) not null auto_increment,
	primary key (i)
) engine=myisam default charset=gbk;

create table country (
	country_id smallint unsigned not null auto_increment,
	country varchar(50) not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (country_id)
) engine=InnoDB default charset=utf8;

alter table ai engine = innodb;

create table city (
	city_id smallint unsigned not null auto_increment,
	city varchar(50) not null,
	country_id smallint unsigned not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (city_id),
	key idx_fk_country_id (country_id),
	constraint 'fk_city_country' foreign key (country_id) references country (country_id) on delete restrict on update cascade
) engine=InnoDB default charset=utf8;

create table tab_memory engine=memory
	select city_id, city, country_id	
	from city group by city_id;

67

/*高级查询*/
select 选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制;
select选项：系统该如何对待查询得到的结果
all:默认的，表示保存所有的记录
-- select选项
select all * from my_simple; --select *;
select distinct * from my_simple;
distinct:去重，去除重复的记录，只保留一条（所有的字段都相同）
字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段全名成不同名的：别名alias
基本语法：字段名[as]别名
select distinct name as name1, name name2 from my_simple;

from数据源
from是为前面的查询提供数据：数据源只要是一个符合二维表结构的数据即可
单表数据
from表名；
多表数据
从多表获取数据，基本语法：from表1， 表2。。。
结果：两张表的记录数相乘，字段数拼接
本质：从第一张表取出一条记录，去接着第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的廉洁：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义：应该尽量避免出现笛卡尔积。

动态数据：
from 后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。
基本语法：from select 字段列表 from 表）as 
select * from (select int_1, int_8 from my_int) as int_my;

where子句
用来从数据表获取数据的时候，进行条件筛选。
数据获取原理：针对表去对应的磁盘获取所有的记录（一条条），where的作用就是在拿到一条结果就开始进行判断，判断是否符合，如果符合就保存下来，如果不符合直接舍弃（不放到内存中）
where是通过运算符进行结果比较来判断数据

group by字句
表示分组的含义：根据指定的字段，将数据进行分组：分组的目标是为了统计
分组统计
group by 字段名；
create table my_student (std_id varchar(10), stu_name varchar(10)) charset=gbk;
insert into my_student values('stu0001', '夏洛');
alter table my_student add class_id int;
update my_student set class_id = 1 where std_id in('stu0001', 'stu0002');
alter table my_student change column std_id stu_id varchar(10);

分组 
select * from my_student group by class_id; --根据班级id进行分组

group by是为了分组后进行数据统计的，如果只是想看数据显示，那么group by没什么含义：group by将数据按照指定的字段分组之后，只会保留每组的第一条记录。
利用一些统计函数：（聚合函数）
count()：统计每组中的数量，如果统计目标是字段，那么不统计为空NULL字段，如果为*那么代表统计记录
alter table my_student add stu_age tinyint unsigned;
update my_student set stu_age = 18, stu_height = 185 where stu_id = 'stu0001'; 
select class_id, count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
select class_id, group_concat(stu_name), count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
avg():求平均值
sum():求后
max():求最大值
min():求最小值
group_concat():为了将分组中指定的字段进行合并（字符串拼接）

多分组
将数据探明某个字段进行分组之后，对已经分组的数据进行再次分组
基本语法：group by 字段1,字段2;//先探明字段1进行排序，之后将结果再按照字段2进行排序
alter table my_student add gender enum('男', '女', '保密');
update my_student set gender = 1 where stu_id in ('stu0001', 'stu0003');
insert into my_student values('stu0005', '小猪', 1, 30, 173, 2);
-- 多分组
select class_id, gender, count(*), group_concat(stu_name) from my_student group by class_id, gender;

分组排序
mysql中，分组默认有排序的功能：按照分组字段进行排序，默认是升序
基本语法：group by 字段[asc|desc], 字段[asc|desc]
select class_id, gender, count(*), group_concat(stu_name) from my_student group by class_id asc, gender desc;

回溯统计
当分组进行多分组之后，往上统计的过程中，需要进行层层上报，将这种层层上报统计的过程称为回溯统计：每一次分组向上统计的过程都会产生一次新的统计数据，而且当前数据对应的分组字段为NULL。
基本语法：group by 字段 [asc|desc]with rollup;
select class_id, count(*) from my_student group by class_id with rollup;
select class_id, gender, count(*) from my_student group by class_id, gender with rollup;

having子句
having的本质和where一样，是用来进行数据条件筛选。
having是在group by子句之后，可以针对分组数据进行统计，但是where不行。
where不能使用聚合函数：聚合函数是用在group by分组的时候，where已经运行完毕。
having 在group by分组之后，可以使用聚合函数或者字段别名（where是从表中取出数据，别名是在数据进入到内存之后才有的）
create table my_student (std_id varchar(10), stu_name varchar(10), class_id tinyint, stu_age tinyint, stu_height tinyint, gender enum('男', '女', '保密')) charset=gbk;
alter table my_student change stu_height stu_height tinyint unsigned;
insert into my_student values('stu0007', '小江', 1, 25, 178, 2);
select class_id, count(*) as number from my_student group by class_id having number >= 4;
强调：having是在group by之后，group by是在where之后，where的时候表示将数据从磁盘拿到内存，where之后的所有操作都是内存操作。

order by排序：根据校对规则对数据进行排序
基本语法：order by 字段 [asc|desc] //asc升序 desc降序
select * from my_student order by stu_height asc;
order by也可以像group by一新进行多字段排序：先按照第一个字段进行排序，然后再按照第二个字段进行排序。
order by 字段1 规则，字段2 规则 
-- 按照班级以及身高排序
select * from my_student order by class_id desc, stu_height;

limit子句
limit限制子句：主要是用来限制记录数量获取
记录数限制
纯粹的限制获取的数量，从第一条到指定的数量
基本语法：limit 数量;
select * from my_student limit 2;
limit通常在查询的时候如果限定为一条记录的时候，使用的比较多：有时候获取多条记录并不能解决业务问题，但是会增加服务器的压力。

分页
利用limit来限制获取指定区间的数据
基本语法：limit offset length; //offset偏移量：从哪开始，length就是具体的获取多少条记录
mysql中记录的数量从0开始
limit 0,2;表示获取前两条记录。
-- 分页获取数据
select * from my_student limit 1, 2;
注意：limit后面的length表示最多获取对应数量，但是如果数量不够，系统不会强求。

查询中的运算符
算术运算符
+、-、*、/、%
基本算术运算：通常不在条件中使用，而是用于结果运算(select 字段中)
create table ysf1(int_1 int, int_2 int, int_3 int, int_4 int)charset utf8;
insert into ysf1 values(100, -100, 0, default);
-- 算术运算
select int_1 + int_2, int_1 - int_2, int_1 * int_2, int_1 / int_2, int_2 / int_3, int_2 % 6, int_4 % 5 from ysf1;

比较运算符
> >= < <= = <>
通常是用来在条件中进行限定结果
=：在mysql中，没有对应==比较符号，就是使用=来进行相等判断
<=>:相等比较
特殊应用：就是在字段结果中进行比较运算
mysql中没有规定select必须有数据表
select '1' <=> 1, 0.02 <=> 0;
在条件判断的时候，还有对应比较运算符：计算区间
select * from my_student where stu_age between 20 and 30;
between中条件1必须小于条件2，反过来不可以

逻辑运算符
and or not
and:逻辑与
or:逻辑或
not:逻辑非
select * from my_student where stu_age >= 20 and stu_age <= 30;

in运算符
in:在什么里面，是用来替代=，当结果不是一个值，而是一个结果集的时候
基本语法：in（结果1， 结果2，结果3.。。），只要当前条件在结果集中出现过，那么就成立
select * from my_student where std_id in ('stu0001', 'stu0004', 'stu0007');

is运算符
is是专门用来判断字段是否为NULL的运算符
基本语法：is null/is not null
select * from my_int where int_6 is null;

like运算符
like运算符：是用来进行模糊匹配（匹配字符串）
基本语法：like匹配模式
匹配模式中，有两种占位符：
_：匹配对应的单个字符
%：匹配多个字符
select * from my_student where stu_name like '小%';

