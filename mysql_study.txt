create table emp(ename varchar(10), hiredate date, sal decimal(10, 2), deptno int(2));
insert into dept values(5, 'dept5'), (6, 'dept6');
update emp set sal=4000 where ename='lisa';
update emp a, dept b set a.sal=a.sal*b.deptno, b.deptname=a.ename where a.deptno = b.deptno;
delete from emp where ename='dony';
delete a, b from emp a, dept b where a.deptno=b.deptno and a.deptno=1;
select ename, hiredate, sal, deptno from emp;
select * from emp where deptno=1;
select * from emp where deptno=1 and sal < 3000;
select * from emp order by sal limit 3;
select * from emp order by deptno, sal desc;
select * from emp order by sal limit 1, 3;
select count(1) from emp;
select deptno, count(1) from emp group by deptno;
select deptno, count(1) from emp group by deptno with rollup;
select deptno, count(1) from emp group by deptno having count(1)>1;
select sum(sal), max(sal), min(sal) from emp;
select ename, deptname from emp,dept where emp.deptno=dept.deptno;
select ename, deptname from emp left join dept on emp.deptno=dept.deptno;
select ename, deptname from dept right join emp on dept.deptno=emp.deptno;
select * from emp where deptno in(select deptno from dept);
select * from emp where deptno = (select deptno from dept limit 1);
select emp.* from emp, dept where emp.deptno=dept.deptno;
select deptno from emp union all select deptno from dept;


alter table t1 modify id1 int zerofill;
alter table t1 modify id2 int(5) zerofill;

CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL PRIMARY KEY);
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, PRIMARY KEY(ID));
CREATE TABLE AI (ID INT AUTO_INCREMENT NOT NULL, UNIQUE(ID));

CREATE TABLE t1 (
	id1 float(5, 2) default NULL,
	id2 double(5, 2) default NULL,
	id3 decimal(5, 2) default NULL
);

alter table t add id2 timestamp;
show create table t;

select length(v), length(c) from vc;

create database test1;
use mysql


create table t (gender enum('M', 'F'));

select 1=0, 1=1, NULL=NULL;

create table ai (
	i bigint(20) not null auto_increment,
	primary key (i)
) engine=myisam default charset=gbk;

create table country (
	country_id smallint unsigned not null auto_increment,
	country varchar(50) not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (country_id)
) engine=InnoDB default charset=utf8;

alter table ai engine = innodb;

create table city (
	city_id smallint unsigned not null auto_increment,
	city varchar(50) not null,
	country_id smallint unsigned not null,
	last_update timestamp not null default current_timestamp on update current_timestamp,
	primary key (city_id),
	key idx_fk_country_id (country_id),
	constraint 'fk_city_country' foreign key (country_id) references country (country_id) on delete restrict on update cascade
) engine=InnoDB default charset=utf8;

create table tab_memory engine=memory
	select city_id, city, country_id	
	from city group by city_id;

67

/*高级查询*/
select 选项 字段列表 from 数据源 where 条件 group by 分组 having 条件 order by 排序 limit 限制;
select选项：系统该如何对待查询得到的结果
all:默认的，表示保存所有的记录
-- select选项
select all * from my_simple; --select *;
select distinct * from my_simple;
distinct:去重，去除重复的记录，只保留一条（所有的字段都相同）
字段列表：有的时候需要从多张表获取数据，在获取数据的时候，可能存在不同表中有同名的字段，需要将同名的字段全名成不同名的：别名alias
基本语法：字段名[as]别名
select distinct name as name1, name name2 from my_simple;

from数据源
from是为前面的查询提供数据：数据源只要是一个符合二维表结构的数据即可
单表数据
from表名；
多表数据
从多表获取数据，基本语法：from表1， 表2。。。
结果：两张表的记录数相乘，字段数拼接
本质：从第一张表取出一条记录，去接着第二张表的所有记录，保留所有结果。得到的结果在数学上有一个专业的廉洁：笛卡尔积，这个结果除了给数据库造成压力，没有其他意义：应该尽量避免出现笛卡尔积。

动态数据：
from 后面跟的数据不是一个实体表，而是一个从表中查询出来得到的二维结果表（子查询）。
基本语法：from select 字段列表 from 表）as 
select * from (select int_1, int_8 from my_int) as int_my;

where子句
用来从数据表获取数据的时候，进行条件筛选。
数据获取原理：针对表去对应的磁盘获取所有的记录（一条条），where的作用就是在拿到一条结果就开始进行判断，判断是否符合，如果符合就保存下来，如果不符合直接舍弃（不放到内存中）
where是通过运算符进行结果比较来判断数据

group by字句
表示分组的含义：根据指定的字段，将数据进行分组：分组的目标是为了统计
分组统计
group by 字段名；
create table my_student (std_id varchar(10), stu_name varchar(10)) charset=gbk;
insert into my_student values('stu0001', '夏洛');
alter table my_student add class_id int;
update my_student set class_id = 1 where std_id in('stu0001', 'stu0002');
alter table my_student change column std_id stu_id varchar(10);

分组 
select * from my_student group by class_id; --根据班级id进行分组

group by是为了分组后进行数据统计的，如果只是想看数据显示，那么group by没什么含义：group by将数据按照指定的字段分组之后，只会保留每组的第一条记录。
利用一些统计函数：（聚合函数）
count()：统计每组中的数量，如果统计目标是字段，那么不统计为空NULL字段，如果为*那么代表统计记录
alter table my_student add stu_age tinyint unsigned;
update my_student set stu_age = 18, stu_height = 185 where stu_id = 'stu0001'; 
select class_id, count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
select class_id, group_concat(stu_name), count(*), max(stu_age), min(stu_height), avg(stu_age) from my_student group by class_id;
avg():求平均值
sum():求后
max():求最大值
min():求最小值
group_concat():为了将分组中指定的字段进行合并（字符串拼接）



























